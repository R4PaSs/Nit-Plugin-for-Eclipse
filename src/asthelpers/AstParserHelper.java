package asthelpers;

import java.io.IOException;
import java.io.PushbackReader;
import java.util.ArrayList;
import java.util.LinkedList;

import lexer.Lexer;
import lexer.LexerException;
import node.AAttrPropdef;
import node.AConcreteInitPropdef;
import node.AConcreteMethPropdef;
import node.ADeferredMethPropdef;
import node.AModule;
import node.AModuledecl;
import node.AStdClassdef;
import node.AStdImport;
import node.PClassdef;
import node.PImport;
import node.PPropdef;
import node.Start;
import node.TBlank;
import node.TEol;
import node.TId;
import node.TKwmodule;
import node.Token;

import org.eclipse.jface.text.IDocument;

import parser.Parser;
import parser.ParserException;
import editor.DocumentBufferStream;

/**
 * @author R4PaSs Class used to simplify the treatments on the AST generated by
 *         the Nit Parser
 */
public class AstParserHelper {

	/**
	 * Gets the AST Start node of a Document if the parsing succeeds or if the
	 * document had been parsed before. Returns null otherwise
	 * 
	 * @param A
	 *            IDocument to parse or get the AST in the reposit
	 * @return A Start node
	 */
	public Start getAstForDocument(IDocument document) {
		DocumentBufferStream dbs = new DocumentBufferStream();

		dbs.setDoc(document);

		PushbackReader pbr = new PushbackReader(dbs, 2);

		Parser pp = new Parser(new Lexer(pbr));

		Start st = null;
		try {
			st = pp.parse();
		} catch (ParserException e) {
		} catch (LexerException e) {
		} catch (IOException e) {
		}

		if (st == null) {
			String moduleName = getModuleNameInFile(dbs);
			if (moduleName != "") {
				return AstReposit.getInstance().getAST(moduleName.trim());
			} else {
				return null;
			}
		} else {
			AModuledecl mod = (AModuledecl) ((AModule) st.getPModule())
					.getModuledecl();
			String mdName = mod.getName().toString().trim();
			AstReposit.getInstance().addOrReplaceAST(mdName, st);
			return st;
		}

	}

	/**
	 * Used in internal to get the name of the module of a file if exists when
	 * the parsing has failed because of an error
	 * 
	 * @param BufferStream
	 *            for a Document
	 * @return The name of the module
	 */
	private String getModuleNameInFile(DocumentBufferStream dbs) {

		dbs.reset();

		Lexer lx = new Lexer(new PushbackReader(dbs));

		Token tk = null;
		do {
			try {
				tk = lx.next();
			} catch (LexerException e) {
			} catch (IOException e) {
			}
		} while (!(tk instanceof TKwmodule));

		do {
			try {
				tk = lx.next();
			} catch (LexerException e) {
				return "";
			} catch (IOException e) {
				return "";
			}
		} while (tk instanceof TBlank || tk instanceof TEol);

		if (tk instanceof TId) {
			return tk.toString();
		} else {
			return "";
		}
	}

	/**
	 * Gets the module node of a nit document in the AST corresponding to the
	 * document
	 * 
	 * @param Start
	 *            node of an AST generated by the Nit Parser
	 * @return A module node
	 */
	public AModule getModuleOfAST(Start startNode) {

		if (startNode.getPModule() instanceof AModule) {
			return (AModule) startNode.getPModule();
		}
		return null;

	}

	/**
	 * Gets the classes of a Module node
	 * 
	 * @param Module node
	 * @return An ArrayList of class nodes, ready to be used
	 */
	public ArrayList<AStdClassdef> getClassesOfModule(AModule module) {

		ArrayList<AStdClassdef> defs = new ArrayList<AStdClassdef>();

		for (PClassdef pclass : module.getClassdefs()) {
			if (pclass instanceof AStdClassdef) {
				AStdClassdef amc = (AStdClassdef) pclass;
				defs.add(amc);
			}
		}
		return defs;
	}

	/**
	 * Gets all the import nodes of a Module node
	 * 
	 * @param Module node
	 * @return List of imports
	 */
	public ArrayList<AStdImport> getImports(AModule module) {

		ArrayList<AStdImport> results = new ArrayList<AStdImport>();
		LinkedList<PImport> pi = module.getImports();

		for (PImport pim : pi) {
			if (pim instanceof AStdImport) {
				results.add((AStdImport) pim);
			}
		}

		return results;
	}

	/**
	 * Gets the propdefs of a Class node
	 * 
	 * @param Class definition node
	 * @return List of propdefs
	 */
	public LinkedList<PPropdef> getPropsOfClass(AStdClassdef className) {

		LinkedList<PPropdef> props = className.getPropdefs();

		return props;
	}

	/**
	 * Gets the concrete methods definitions in the props list
	 * 
	 * @param Properties got from the getPropsOfClass
	 * @return List of concrete method definitions
	 */
	public ArrayList<AConcreteMethPropdef> getConcreteMethsInPropList(
			LinkedList<PPropdef> props) {
		ArrayList<AConcreteMethPropdef> methods = new ArrayList<AConcreteMethPropdef>();

		for (PPropdef prp : props) {
			if (prp instanceof AConcreteMethPropdef) {
				methods.add((AConcreteMethPropdef) prp);
			}
		}

		return methods;
	}

	/**
	 * Gets the deferred methods definitions (external definitions) in the props list
	 * 
	 * @param  Properties got from the getPropsOfClass
	 * @return List of deferred method definitions
	 */
	public ArrayList<ADeferredMethPropdef> getDeferredMethsInPropList(
			LinkedList<PPropdef> props) {
		ArrayList<ADeferredMethPropdef> methods = new ArrayList<ADeferredMethPropdef>();

		for (PPropdef prp : props) {
			if (prp instanceof ADeferredMethPropdef) {
				methods.add((ADeferredMethPropdef) prp);
			}
		}

		return methods;
	}

	/**
	 * Gets the attributes in the props list
	 * 
	 * @param Properties got from the getPropsOfClass
	 * @return List of attributes
	 */
	public ArrayList<AAttrPropdef> getNonMethPropsInPropList(
			LinkedList<PPropdef> props) {
		ArrayList<AAttrPropdef> nonMethProps = new ArrayList<AAttrPropdef>();

		for (PPropdef prp : props) {
			if (prp instanceof AAttrPropdef) {
				nonMethProps.add((AAttrPropdef) prp);
			}
		}

		return nonMethProps;
	}

	/**
	 * Gets the init_ blocks
	 * 
	 * @param Properties got from the getPropsOfClass
	 * @return List of construct methods found in the props list
	 */
	public ArrayList<AConcreteInitPropdef> getConstructMethsInPropList(
			LinkedList<PPropdef> props) {
		ArrayList<AConcreteInitPropdef> constructs = new ArrayList<AConcreteInitPropdef>();

		for (PPropdef prp : props) {
			if (prp instanceof AConcreteInitPropdef) {
				constructs.add((AConcreteInitPropdef) prp);
			}
		}

		return constructs;
	}
}
