package asthelpers;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PushbackReader;
import java.util.ArrayList;
import java.util.LinkedList;

import lexer.Lexer;
import lexer.LexerException;
import node.AAttrPropdef;
import node.AConcreteInitPropdef;
import node.AConcreteMethPropdef;
import node.ADeferredMethPropdef;
import node.AModule;
import node.AModuleName;
import node.AModuledecl;
import node.AStdClassdef;
import node.AStdImport;
import node.PClassdef;
import node.PImport;
import node.PPropdef;
import node.Start;

import org.eclipse.core.resources.IFile;
import org.eclipse.jface.text.IDocument;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.part.FileEditorInput;

import parser.Parser;
import parser.ParserException;
import plugin.NitActivator;
import builder.NitNature;
import editor.DocumentBufferStream;
import general_helpers.StringArrayHelp;

/**
 * @author R4PaSs Class used to simplify the treatments on the AST generated by
 *         the Nit Parser
 */
public class AstParserHelper {

	public AstParserHelper() {
	}

	/**
	 * Gets the AST Start node of a Document if the parsing succeeds or if the
	 * document had been parsed before. Returns null otherwise
	 * 
	 * @param A
	 *            IDocument to parse or get the AST in the reposit
	 * @return A Start node
	 */
	public Start getAstForDocument(IDocument document) {

		DocumentBufferStream dbs = new DocumentBufferStream();

		dbs.setDoc(document);

		Lexer lex = this.getLexForSource(dbs);
		if (lex != null) {
			return getAstForDocumentBody(lex);
		} else {
			return null;
		}
	}

	public Start getAstForDocument(IFile file) {

		Lexer lex = getLexForSource(file);

		if (lex != null) {
			return this.getAstForDocumentBody(lex);
		} else {
			return null;
		}
	}

	public Start getAstForDocument(AStdImport imp, IFile fileToSeekFrom) {
		// Get IFile for this import
		AModuleName moduleName = (AModuleName) imp.getName();
		String mod = moduleName.toString();

		String fullPathInOS = fileToSeekFrom.getLocation().toString();

		String[] separatedPath = fullPathInOS.split("/");

		StringArrayHelp sah = new StringArrayHelp();

		while (separatedPath.length > 1) {
			separatedPath[separatedPath.length - 1] = mod.trim();

			// Check if a file with .nit extension exists, else, try to find a
			// directory with that name and get the file bearing this name in
			// that directory if there is
			File toCheck = new File(sah.join(separatedPath, "/") + ".nit");

			if (toCheck.exists() && toCheck.isFile()) {
				return this
						.getAstForDocumentBody(this.getLexForSource(toCheck));
			}else{
				File dir = new File(sah.join(separatedPath, "/"));
				if(dir.exists() && dir.isDirectory()){
					File finalFile = new File(sah.join(separatedPath, "/") + "/" + separatedPath[separatedPath.length-1] + ".nit");
					
					if(finalFile.exists() && finalFile.isFile()){
						return this.getAstForDocumentBody(this.getLexForSource(finalFile));
					}
				}
			}
			
			//Remove the last
			separatedPath = sah.removeLast(separatedPath);
		}

		return null;
	}

	private Start getAstForDocumentBody(Lexer lex) {

		Parser pp = new Parser(lex);

		ProjectAutoParser pap = new ProjectAutoParser();

		Start st = null;
		try {
			st = pp.parse();
		} catch (ParserException e) {
			if (NitActivator.DEBUG_MODE)
				e.printStackTrace();
		} catch (LexerException e) {
			if (NitActivator.DEBUG_MODE)
				e.printStackTrace();
		} catch (IOException e) {
			if (NitActivator.DEBUG_MODE)
				e.printStackTrace();
		}

		IFile fileBoundToIDocument = null;
		// First get the active editor, if nit editor, get the file bound to the
		// IDocument
		try {
			IEditorInput ie = PlatformUI.getWorkbench()
					.getActiveWorkbenchWindow().getActivePage()
					.getActiveEditor().getEditorInput();
			if (ie instanceof FileEditorInput) {
				fileBoundToIDocument = ((FileEditorInput) ie).getFile();
			}

			try {
				fileBoundToIDocument.getProject()
						.getNature(NitNature.NATURE_ID);
			} catch (Exception e) {
				if (NitActivator.DEBUG_MODE)
					e.printStackTrace();
			}

			pap.addToQueue(fileBoundToIDocument);
		} catch (Exception e) {
			if (NitActivator.DEBUG_MODE)
				e.printStackTrace();
		}

		if (st == null) {
			// If st is null, the parsing has failed, for whatever reason
			// (Parser/Lexer Exception or IO error)
			// Therefore, call the compiler to find the error spot and have it
			// pop up in the editor
			// This is done in the ProjectAutoParser class

			return null;
		} else {
			AModuledecl mod = (AModuledecl) ((AModule) st.getPModule())
					.getModuledecl();
			String mdName = mod.getName().toString().trim();
			try {
				((NitNature) fileBoundToIDocument.getProject().getNature(
						NitNature.NATURE_ID)).getAstReposit().addOrReplaceAST(
						mdName, st);
			} catch (Exception e) {
				if (NitActivator.DEBUG_MODE)
					e.printStackTrace();
			}
			return st;
		}
	}

	private Lexer getLexForSource(DocumentBufferStream dbs) {
		dbs.reset();

		return new Lexer(new PushbackReader(dbs, 2));
	}

	private Lexer getLexForSource(IFile file) {
		PushbackReader pbr = null;
		try {
			pbr = new PushbackReader(
					new FileReader(file.getFullPath().toFile()), 2);
		} catch (FileNotFoundException e1) {
			if (NitActivator.DEBUG_MODE)
				e1.printStackTrace();
		}
		if (pbr != null) {
			return new Lexer(pbr);
		}
		return null;
	}

	private Lexer getLexForSource(File file) {
		Lexer lex = null;
		if (file.exists()) {
			try {
				lex = new Lexer(new PushbackReader(new FileReader(file)));
			} catch (FileNotFoundException e) {
				if (NitActivator.DEBUG_MODE)
					e.printStackTrace();
			}
		}
		return lex;
	}

	/**
	 * Gets the module node of a nit document in the AST corresponding to the
	 * document
	 * 
	 * @param Start
	 *            node of an AST generated by the Nit Parser
	 * @return A module node
	 */
	public AModule getModuleOfAST(Start startNode) {

		if (startNode.getPModule() instanceof AModule) {
			return (AModule) startNode.getPModule();
		}
		return null;

	}

	/**
	 * Gets the classes of a Module node
	 * 
	 * @param Module
	 *            node
	 * @return An ArrayList of class nodes, ready to be used
	 */
	public ArrayList<AStdClassdef> getClassesOfModule(AModule module) {

		ArrayList<AStdClassdef> defs = new ArrayList<AStdClassdef>();

		for (PClassdef pclass : module.getClassdefs()) {
			if (pclass instanceof AStdClassdef) {
				AStdClassdef amc = (AStdClassdef) pclass;
				defs.add(amc);
			}
		}
		return defs;
	}

	/**
	 * Gets all the import nodes of a Module node
	 * 
	 * @param Module
	 *            node
	 * @return List of imports
	 */
	public ArrayList<AStdImport> getImports(AModule module) {

		ArrayList<AStdImport> results = new ArrayList<AStdImport>();
		LinkedList<PImport> pi = module.getImports();

		for (PImport pim : pi) {
			if (pim instanceof AStdImport) {
				results.add((AStdImport) pim);
			}
		}

		return results;
	}

	/**
	 * Gets the propdefs of a Class node
	 * 
	 * @param Class
	 *            definition node
	 * @return List of propdefs
	 */
	public LinkedList<PPropdef> getPropsOfClass(AStdClassdef className) {

		LinkedList<PPropdef> props = className.getPropdefs();

		return props;
	}

	/**
	 * Gets the concrete methods definitions in the props list
	 * 
	 * @param Properties
	 *            got from the getPropsOfClass
	 * @return List of concrete method definitions
	 */
	public ArrayList<AConcreteMethPropdef> getConcreteMethsInPropList(
			LinkedList<PPropdef> props) {
		ArrayList<AConcreteMethPropdef> methods = new ArrayList<AConcreteMethPropdef>();

		for (PPropdef prp : props) {
			if (prp instanceof AConcreteMethPropdef) {
				methods.add((AConcreteMethPropdef) prp);
			}
		}

		return methods;
	}

	/**
	 * Gets the deferred methods definitions (external definitions) in the props
	 * list
	 * 
	 * @param Properties
	 *            got from the getPropsOfClass
	 * @return List of deferred method definitions
	 */
	public ArrayList<ADeferredMethPropdef> getDeferredMethsInPropList(
			LinkedList<PPropdef> props) {
		ArrayList<ADeferredMethPropdef> methods = new ArrayList<ADeferredMethPropdef>();

		for (PPropdef prp : props) {
			if (prp instanceof ADeferredMethPropdef) {
				methods.add((ADeferredMethPropdef) prp);
			}
		}

		return methods;
	}

	/**
	 * Gets the attributes in the props list
	 * 
	 * @param Properties
	 *            got from the getPropsOfClass
	 * @return List of attributes
	 */
	public ArrayList<AAttrPropdef> getNonMethPropsInPropList(
			LinkedList<PPropdef> props) {
		ArrayList<AAttrPropdef> nonMethProps = new ArrayList<AAttrPropdef>();

		for (PPropdef prp : props) {
			if (prp instanceof AAttrPropdef) {
				nonMethProps.add((AAttrPropdef) prp);
			}
		}

		return nonMethProps;
	}

	/**
	 * Gets the init_ blocks
	 * 
	 * @param Properties
	 *            got from the getPropsOfClass
	 * @return List of construct methods found in the props list
	 */
	public ArrayList<AConcreteInitPropdef> getConstructMethsInPropList(
			LinkedList<PPropdef> props) {
		ArrayList<AConcreteInitPropdef> constructs = new ArrayList<AConcreteInitPropdef>();

		for (PPropdef prp : props) {
			if (prp instanceof AConcreteInitPropdef) {
				constructs.add((AConcreteInitPropdef) prp);
			}
		}

		return constructs;
	}
}
